\documentclass[../../master.tex]{subfiles}

\begin{document}



\chapter{Implementation: Variational Monte Carlo}
The following is a description of the implementation of the VMC framework described in chapter \ref{VMC}. The main body and workhorse of the method consists of about $4\,000$ significant lines\footnote{As counted by the \lstinline{cloc} program which counts \emph{significant} lines of code, leaving out blank lines, comment lines, etc. \cite{cloc}} of \CC{}  code. It is object oriented and modular, and written to be as general as possible while still retaining execution speed. It consists of about 12 significant classes, with associated sub-classes, of which a generic user is required to interact with four in order to run simulations: The managing \inlinecc{System} class, the \inlinecc{Atom} class for setting up the chemical environment, and appropriate sub-classes of the \inlinecc{WaveFunction} and \inlinecc{Orbital} classes to choose which kind of wave function is to be used.

Wherever possible, the modularity makes it possible to in principle directly reuse the classes for different purposes. As an example, the \inlinecc{Metropolis} class\textemdash which handles the accept/reject Metropolis steps and generates a Markov chain of samples drawn from our PDF\textemdash can be reused to run e.g.\ a statistical mechanics simulation of the Ising spin model without changing more than a handful lines of code. The same is true of e.g.\ the \inlinecc{Sampler} class which handles sampling the local energy and computing averages, etc.: this class is reusable without changing \emph{a single line of code}.

The developed code can perform multiple different calculations: Atomic or molecular systems in addition to harmonic oscillator quantum dot systems are supported. Various different Slater determinant types are available, such as \emph{direct evaluation} determinant, or the more sophisticated and faster \emph{inverse} determinant machinery. In either case, a relative distance-dependent Jastrow factor can be included. The orbitals which build the Slater can be chosen as either Slater-type orbitals (STO) or Gaussian-type orbitals (GTO). The latter can be taken from a Hartree-Fock basis computed using the code described in chapter \ref{hfimplementation}, automatically parsed from the Hartree-Fock output by the \inlinecc{HatreeFockBasisParser} class. 

However, the only parts of the code which have been rigorously tested and which will be described in the following are the molecular full inverse Slater machinery with a two-body Jastrow factor, filled with either STOs or GTOs. 

We will start off with a few usage examples and then later expand on the implementation of some key classes and methods.

\section{Introductory examples\label{vmcexample}}
The simplest usage of the VMC code requires only a few lines of \CC{}  code:
\begin{lstlisting}[language={[std]c++}]
int     Z       = 2;
double  alpha   = 1.843;
double  beta    = 0.347;
vec     position{0,0,0};

System He;
He.setImportanceSampling(true);
He.addCore          (new Atom               (&He, position, Z));
He.setWaveFunction  (new SlaterWithJastrow  (&He, beta));
He.setOrbital       (new HydrogenOrbital    (alpha));
He.runMetropolis    ((int) 1e7);
\end{lstlisting}
First the \inlinecc{System} instance is created, and importance sampling is enabled. Then a new \inlinecc{Core} is added: a charge-$2$ atom placed at the origin. The \inlinecc{WaveFunction} is selected as a standard \inlinecc{SlaterWithJastrow} which is then filled with \inlinecc{HydrogenOrbital}s. The $\alpha$ and $\beta$ parameters are the variational input parameters in the hydrogenic radial wave functions and the Jastrow factor, respectively. The values of $\alpha=1.843$ and $\beta=0.347$ have been optimized for a single \ce{He} atom.
\begin{figure}[p]
\begin{lstlisting}
 =============== Starting Metropolis Algorithm ============== 
 => Number of steps:       1e+07      
 => Number of dimensions:  3          
 => Number of electrons:   2          
 => Step length:           1          
 => Number of cores:       1          
      ------------------------------------------------------- 
      | He                   (0.000, 0.000, 0.000)          | 
      ------------------------------------------------------- 

 =======================================================================
                    Total                           Block 
  Step       Energy     Std.dev.       Energy     Variance    Acc. rate 
 -----------------------------------------------------------------------
   5e4       -2.8894      0.13448      -2.8764   3.4756e-05       0.9976
   1e5       -2.8825     0.069696      -2.8367   3.7517e-05       0.9976
   1e5       -2.8814     0.047099      -2.9346   6.4217e-05       0.9964
   2e5       -2.8852     0.035672      -2.8164   0.00011602       0.9976
   2e5       -2.8851      0.02869      -2.8837   6.4744e-05        0.994
   3e5       -2.8878     0.024047      -2.9387   0.00012301       0.9952

                                    ...

   9e6       -2.8896    0.0010202      -2.8407   5.2671e-05       0.9944
   9e6       -2.8895    0.0010167      -2.8228   3.3053e-05       0.9972
   9e6       -2.8895     0.001013       -2.897   4.0035e-05       0.9968
   9e6       -2.8896    0.0010092      -2.8771   5.1971e-05        0.994
   9e6       -2.8896     0.001005      -2.8623    3.122e-05        0.998
 =======================================================================

 Metropolis Algorithm finished. 

 => Metropolis steps:                                1e+07   
 => Final acceptance rate:              0.9967614900486612 
 => Final energy average:               -2.889522415923047 
 => Final variance:                  1.002073906587686e-06 
 ============================================================ 
\end{lstlisting}
\caption{Output of the first example program show at the start of section \ref{vmcexample}. The first two \inlinecc{Total}-columns show the full energy computed so far, treating blocks of $2500$ Monte Carlo step as single samples. The three right hand side \inlinecc{Block}-columns show the values computed for the last completed such block. Please note that the block variance shown is treating every single Monte Carlo cycle as an independent sample, and thus massively underestimates the size of the variance. The same is also true of the printed \inlinecc{Final variance} at the very end of the output. \label{fig:vmcexample}}
\end{figure}

Running the above code gives on the fly output shown in \fig{vmcexample}, and the final energy $E=-2.890\pm0.001E_h$.

More complicated systems can also easily be set up for simulation, e.g.\ the following code runs a simulation on \ce{Ne+} cation with non-interacting electrons, no Jastrow-factor, and a manually specified importance sampled step length $\delta t$:
\begin{lstlisting}[language={[std]c++}]
System Ne;
Ne.setImportanceSampling    (true);
Ne.setElectronInteraction   (false);
Ne.setStepLength    (0.025);
Ne.addCore          (new Atom               (&Ne, position, 10, 5, 4));
Ne.setWaveFunction  (new SlaterWithJastrow  (&Ne, -1, false));
Ne.setOrbital       (new HydrogenOrbital    (10.0));
Ne.runMetropolis    ((int) 1e7);
\end{lstlisting}
The penultimate input parameter of the \inlinecc{Atom} constructor defines the number of spin-up electrons, while the last parameter gives the number of spin-down electrons. As the total number of electrons is $9$, while the nucleus charge is $Z=10$, this defines a \ce{Ne+} ion. Since the hydrogenic Slater determinant forms the \emph{exact} wave function for non-interacting electrons, the energy $E=-187.5E_h$ is calculated with vanishing variance. 

Cartesian Gaussian orbitals can be requested by calling \inlinecc{System::setOrbital} with a \inlinecc{SlaterTypeOrbital} object. The name of a basis file\textemdash output from the Hatree-Fock code described in detail in section \ref{hfimplementation}, defining the chemical environment and the basis set itself\textemdash is given as input to the constructor of \inlinecc{SlaterTypeOrbital}. The basis file is the result of previously ran Hartree-Fock calculations, and defines the positions of any atoms present. This means there is no need to specify nucleonic positions when \inlinecc{SlaterTypeOrbital}s are used. An example calculation can be ran by the following  code:
\begin{lstlisting}[language={[std]c++}]
string  basisFileName = "Be-STO-3G";
System  Be;
Be.setImportanceSampling(true);
Be.setWaveFunction  (new SlaterWithJastrow  (&Be, beta, true));
Be.setOrbital       (new GaussianOrbital    (&Be, basisFileName));
Be.runMetropolis    ((int) 1e7);
\end{lstlisting}
Here, a STO-3G Gaussian Hartree-Fock basis set is used. 

\renewcommand{\r}{{\bf r}}
\newcommand{\x}{{\bf x}}
\renewcommand{\R}{{\bf R}}
\newcommand{\Psit}{\Psi_\text{T}}
\newcommand{\pphi}{\tilde{\phi}}
\section{Overview of select classes}
\subsection{The SlaterWithJastrow class}
The work-horse of the VMC program is the \inlinecc{WaveFunction} class and associated sub-classes. The code can in principle be run with any trial wave function, as long as it can be evaluated, and allows the computation of the Laplacian (and the gradient if importance sampling is desired). 

The particular sub-class used in the entirety of the current work is the \inlinecc{SlaterWithJastrow} class. It represents a product of a Slater determinant $D(\R)$ and a two-body Jastrow factor $J(\R)$,
\begin{align}
\Psit(\R) = D(\R)J(\R).
\end{align}
The determinant is populated with orbitals represented by the \inlinecc{Orbital} class. When using a \emph{restricted} set of orbitals\textemdash in the sense that each \emph{spatial} orbital is doubly occupied by one spin-up and one spin-down electron\textemdash the full Slater determinant 
\begin{align}
D(\R) = \frac{1}{\sqrt{N!}}\vmat{ccccc}{
	\pphi_1(\r_1) & \pphi_2(\r_1) & \pphi_3(\r_1) & \dots  & \pphi_N(\r_1) \\
	\pphi_1(\r_2) & \pphi_2(\r_2) & \pphi_3(\r_2) & \dots  & \pphi_N(\r_2) \\
	\pphi_1(\r_3) & \pphi_2(\r_3) & \pphi_3(\r_3) & \dots  & \pphi_N(\r_3) \\
	\vdots 		 & \vdots 		& \vdots	   & \ddots & \vdots 	   \\ 
	\pphi_1(\r_N) & \pphi_2(\r_N) & \pphi_3(\r_N) & \dots  & \pphi_N(\r_N)
}
\end{align}
is \emph{singular}. The restricted orbitals $\pphi(\r)$ are spatially pairwise equal, odd indices carry spin-up while even indices carry spin-down. This means we can write the determinant in terms of \emph{spatial} orbitals $\phi_{k}(\r)$ and $\phi_{k}(\r)$ as
\begin{align}
D(\R) = \frac{1}{\sqrt{N!}}\vmat{cccccc}{
	\phi_{1\uparrow}(\r_1) & \phi_{1\downarrow}(\r_1) & \phi_{2\uparrow}(\r_1) & \phi_{2\downarrow}(\r_1) & \dots  & \phi_{N/2\downarrow}(\r_1) \\
	\phi_{1\uparrow}(\r_2) & \phi_{1\downarrow}(\r_2) & \phi_{2\uparrow}(\r_2) & \phi_{2\downarrow}(\r_2) & \dots  & \phi_{N/2\downarrow}(\r_2) \\
	\phi_{1\uparrow}(\r_3) & \phi_{1\downarrow}(\r_3) & \phi_{2\uparrow}(\r_3) & \phi_{2\downarrow}(\r_3) & \dots  & \phi_{N/2\downarrow}(\r_3) \\
	\vdots 		 & \vdots 		& \vdots	   & \vdots 	  & \ddots & \vdots 	  \\ 
	\phi_{1\uparrow}(\r_N) & \phi_{1\downarrow}(\r_N) & \phi_{2\uparrow}(\r_N) & \phi_{2\downarrow}(\r_N) & \dots  & \phi_{N/2\downarrow}(\r_N)
},
\end{align} 
where $\phi_{k\uparrow}(\r)=\phi_{k}(\r)\chi(\uparrow)=\pphi_{2k-1}(\r)$ and $\phi_{k\downarrow}(\r)=\phi_{k}(\r)\chi(\downarrow)=\pphi_{2k}(\r)$. The $\chi$s represent spin-$1/2$ spinors. It can be shown that for a spin-independent operator, such as all the Hamiltonians in the present work, the expectation value 
\begin{align}
E_\text{T} = \frac{\langle\Psi_\text{T}|\hat H|\Psi_\text{T}\rangle}{\langle\Psi_\text{T}|\Psi_\text{T}\rangle},
\end{align}
is invariant under a splitting of the determinant. We can split the Slater in two factors: one representing the spatial orbitals for the spin-up electrons, and one representing the corresponding orbitals for the spin-down electrons. Even though the new wave function is no longer\emph{anti-symmetric} w.r.t.\ interchange of two electrons of opposite spin, the expectation value\textemdash all we care about\textemdash remains the same, with the added benefit of reducing computational cost \cite{hjorth-jensen}\comment{p520}.

The full split-determinant trial wave function takes the form
\begin{align}
\Psi_\text{T}=D_\uparrow(\R) D_\downarrow(\R) J(\R),
\end{align}
where 
\begin{align}
D_\uparrow(\R)\propto \vmat{ccccc}{
	\phi_{1\uparrow}(\r_1) & \phi_{2\uparrow}(\r_1) & \phi_{3\uparrow}(\r_1) & \dots  & \phi_{N/2\uparrow}(\r_1) \\
	\phi_{1\uparrow}(\r_2) & \phi_{2\uparrow}(\r_2) & \phi_{3\uparrow}(\r_2) & \dots  & \phi_{N/2\uparrow}(\r_2) \\
	\phi_{1\uparrow}(\r_3) & \phi_{2\uparrow}(\r_3) & \phi_{3\uparrow}(\r_3) & \dots  & \phi_{N/2\uparrow}(\r_3) \\
	\vdots 		 & \vdots 		& \vdots	   & \ddots & \vdots 	   \\ 
	\phi_{1\uparrow}(\r_N) & \phi_{2\uparrow}(\r_N) & \phi_{3\uparrow}(\r_N) & \dots  & \phi_{N/2\uparrow}(\r_N)
},
\end{align}
and a corresponding expression for $D_\downarrow(\R)$. Since we are always working with ratios of wave functions in the Metropolis-Hastings algorithm, the normalization factor of the determinant does not enter our equations and we can safely forget about it from now on.

\subsubsection{Evaluating the wave function ratio}
In order to perform the Metropolis test step of the Metropolis-Hastings algorithm, we need to be able to calculate the ratio 
\begin{align}
R=\frac{\Psi_\text{T}(\R_\text{new})}{\Psi_\text{T}(\R_\text{old})}.
\end{align}
We may of course directly evaluate the determinant at every Monte Carlo step. After the splitting, we can rewrite $R$ in a more convenient form:
\begin{align}
R=\left[\frac{D_\uparrow(\R_\text{new})D_\downarrow(\R_\text{new})}{D_\uparrow(\R_\text{old})D_\downarrow(\R_\text{old})}\right] \left.\frac{J(\R_\text{new})}{J(\R_\text{old})} \right.\equiv R_\text{SD}R_\text{J}. \label{eq:VMCI1}
\end{align}
From this it is immediately obvious that if the new coordinate set $\R_\text{new}$ differs from the old $\R_\text{old}$ for \emph{only a single electron} of spin $\uparrow$ ($\downarrow$) then the spin-down (spin-up) determinants falls out of \eq{VMCI1}. In other words: moving only one electron at the time the ostensibly halves the required computation cost associated with $R_\text{SD}$. This of course comes at the cost of correlation\textemdash subsequent samples are less correlated if we simultaneously move multiple electrons\textemdash a complication which we will return to shortly.

Even after the splitting however, the direct evaluation of our determinants still requires $\mathcal{O}(N^3)$ operations, albeit with a pre-factor $1/8$ compared to the original full determinant. It turns out that we can do better.

Consider the terms of the Slater \emph{matrix}: $D_{ij}(\r)\equiv \phi_j(\r_i)$. The usual Laplace-expansion of the determinant is defined as 
\begin{align}
|D|=\sum_{j=1}^N D_{ij}C_{ij},
\end{align}
where $C_{ij}$ is the $i,j$ \emph{cofactor} of $D$, i.e.\ the determinant of the sub-matrix with row $i$ and column $j$ removed multiplied by $(-1)^{i+j}$ \cite{lay}\comment{p165}. The determinant of the sub-matrix is called the $i,j$ \emph{minor} of $D$. By using \emph{Cramer's rule}\footnote{Cramer's rule states that for any inertible $n\times n$ matrix $A$ and ${\bf b}\in \mathbb{R}^n$, the unique solution $\x$ of the matrix-vector equation $A\x={\bf b}$ has entries 
\begin{align}
x_i=\frac{|A_i({\bf b})|}{|A|}, \ \ \ \text{ where } \ \ i=1,2,\dots,n,
\end{align}
where $A_i({\bf b})$ is the matix formed by replacing the $i$-th column of $A$ by ${\bf b}$ \cite{lay}\comment{p177}.} we can find an explicit expression for the matrix inverse in terms of the determinant as \cite{hassani}\comment{p98}
\begin{align}
D^{-1}=\frac{\text{adj}D}{|D|}.
\end{align}
The \emph{adjugate} matrix\footnote{Sometimes, rather confusingly, called the \emph{adjoint}. In more modern terminology, the \emph{adjoint} is reserved for the complex conjugate-transpose, while the transposed cofactor matrix is called the \emph{adjugate} or the \emph{classical adjoint} \cite{householder,hjorth-jensen}\comment{p166-168}\comment{521}.}, $\text{adj}D$, is simply the transposed matrix of cofactors. In terms of the entries, we can write
\begin{align}
|D|=\sum_{j=1}^n \frac{C_{ji}}{D^{-1}_{ij}} = \sum_{j=1}^n D_{ij}C_{ji}.
\end{align}

As only one electron is moved at each Monte Carlo step, only a single row of the Slater matrix changes at each cycle. Recall that the $i,j$ cofactors are determinants of the sub-matrix resulting from removing column $i$ and row $j$ from $D$. This means that as row $i$ of $D$ is changed, the $i$-th column of the adjugate remains unchanged. In short, $C_{ij}(\r_\text{new})=\text{adj}D_{ij}(\r_\text{old})=C_{ji}(\r_\text{old})$ \cite{hjorth-jensen}\comment{p521}.

By definition, the Slater matrix and it's inverse must satisfy 
\begin{align}
\sum_{k=1}^n D_{ik}D^{-1}_{kj}=\delta_{ij},
\end{align}
meaning the denominator drops out of \eq{VMCI2} and $R_\text{SD}$ simplifies immensely to \cite{hammond,ceperly,hjorth-jensen}\comment{p276}\comment{}\comment{p521}
\begin{align}
\frac{D(\R_\text{new})}{D(\R_\text{old})}=R_\text{SD}&=\frac{\sum_{j=1}^n D_{ij}(\r_\text{new})C_{ji}(\r_\text{old}) }{\sum_{j=1}^n D_{ij}(\r_\text{old})C_{ji}(\r_\text{old}) } \nn\\
%
&= \frac{\sum_{j=1}^n D_{ij}(\r_\text{new})D^{-1}_{ji}(\r_\text{old})|D(\r_\text{old})| }{\sum_{j=1}^n D_{ij}(\r_\text{old})D^{-1}_{ji}(\r_\text{old})|D(\r_\text{old})| } \label{eq:VMCI2}\\
%
&= \sum_{j=1}^n D_{ij}(\r_\text{new})D^{-1}_{ji}(\r_\text{old}). \label{eq:VMCI3}
\end{align}
Note carefully that the inverse need only be re-calculated \emph{if} the new configuration is accepted in the Metropolis test.

\eq{VMCI3} is implemented in the VMC code as
\begin{lstlisting}[language={[std]c++}]
void SlaterWithJastrow::computeSlaterRatio() {
    Electron* iElectron = m_system->getElectrons().at(m_changedElectron);
    int    	i  			= iElectron->getSpinIndex();
    int     nElectrons  = (m_spinChanged == 1 ? m_numberOfSpinUpElectrons :
                                                m_numberOfSpinDownElectrons);
    double 	xi 			= iElectron->getPosition().at(0);
    double 	yi 			= iElectron->getPosition().at(1);
    double 	zi 			= iElectron->getPosition().at(2);
    mat&    slater      = (m_spinChanged == 1 ? m_slaterUp : m_slaterDown);

    double sum = 0;
    for (int j = 0; j < nElectrons; j++) {
        sum += m_orbital->evaluate(xi,yi,zi,j,m_spinChanged) * slater(j,i);
    }
    m_Rsd = sum;
}
\end{lstlisting}
The \inlinecc{m_changedElectron} is communicated to the \inlinecc{WaveFunction} by the \inlinecc{Metropolis} class as it suggets a step, and \inlinecc{m_spinChanged}\textemdash the spin of the moved electron\textemdash is subsequently found. Depending on this spin projection, we index into either \inlinecc{m_slaterUp} or \inlinecc{m_slaterDown} according to the \emph{spin index} of the moved electron. All electrons have a unique global indentifying index $k$, but they also have a local place in the spin-up (spin-down) determinant: This is what we denote by the spin-index.

The \inlinecc{m_orbital} variable holds an instance of the class corresponding to the spin-orbitals which populate the Slater determinant. We give an outline of the \inlinecc{Orbital} in section \ref{orbital}.

\subsubsection{Updating the inverse}
The algorithm of the previous section requires the inverse of the Slater matrix, evaluated at the previous electronic configuration, to be know. In principle we may simply directly evaluate the inverse for every Monte Carlo cycle, but the $\mathcal{O}(N^3)$ computational scaling cost quickly makes this approach unfeasible. We require therefore a more efficient algorithm which makes use of the fact that when we update it, the inverse is already known at the old configuration. Recall that the new Slater matrix differs from the old one only in a single row.

We use an algorithm based on the Sherman-Morrison formula \cite{sherman}. The method due to Sherman and Morrison updates the inverse given a single changed index in the original matrix, but this is readily extended to give the change in $D^{-1}$ given the replacement of a full row of the matrix $D$. The full update formula is given by \cite{hammond}\comment{p277}
\begin{align}
D_{kj}^{-1}(\r_\text{new}) = \left\{ \mat{lccr}
{
	\displaystyle D_{kj}^{-1}(\r_\text{old}) - \frac{1}{R_\text{SD}}D^{-1}_{ji}(\r_\text{new})\sum_{l=1}^n D_{il}(\r_\text{new})D_{lj}^{-1}(\r_\text{new}) & & \text{if} & j\not=i \\
	%
	\displaystyle \frac{1}{R_\text{SD}}D_{kj}^{-1}(\r_\text{old}) & & \text{if} & j=i 
}\right. \label{eq:VMCI4}
\end{align}
The modified Sherman-Morrison scheme of \eq{VMCI4} is implemented in the VMC framework as 
\begin{lstlisting}[language={[std]c++}]

void SlaterWithJastrow::updateSlaterInverse() {
    Electron*  iElectron  = m_system->getElectrons().at(m_changedElectron);

    const int    i       = iElectron->getSpinIndex();
    const int    sc      = m_spinChanged;
    const double x    	 = iElectron->getPosition().at(0);
    const double y    	 = iElectron->getPosition().at(1);
    const double z       = iElectron->getPosition().at(2);

    mat& newS        = (m_spinChanged == 1 ? m_slaterUp    : m_slaterDown);
    mat& oldS        = (m_spinChanged == 1 ? m_slaterUpOld : m_slaterDownOld);
    int  nElectrons  = (m_spinChanged == 1 ? m_numberOfSpinUpElectrons :
                                             m_numberOfSpinDownElectrons);

    for (int k = 0; k < nElectrons; k++) {
        for (int j = 0; j < nElectrons; j++) {
            if (j != i) {
                double sum = 0;
                for (int l = 0; l < nElectrons; l++) {
                    sum += oldS(l,j) * m_orbital->evaluate(x,y,z,l,sc);
                }
                newS(k,j) = oldS(k,j) - oldS(k,i) * sum / m_Rsd;
            } else {
                newS(k,j) = oldS(k,i) / m_Rsd;
            }
        }
    }
}
\end{lstlisting}
The Slater matrix evaluated at the old configuration is contained in the variables \inlinecc{m_slaterUpOld} and \inlinecc{m_slaterDownOld}. Note carefully that the $R_\text{SD}$ value stored in \inlinecc{m_Rsd} here is the \emph{updated} value, which is independent of $D^{-1}(\R_\text{new})$ and so can be calculated before we update the inverse in this member function.

At the very start of the Metropolis run, the full Slater matrix needs to be calculated and inverted \emph{once}. This is done (in addition to a whole range of other operations) in \inlinecc{SlaterWithJastrow::evaluateWaveFunctionInitial},
\begin{lstlisting}[language={[std]c++}]
void SlaterWithJastrow::evaluateWaveFunctionInitial() {
    ...
    const int eUp   = m_numberOfSpinUpElectrons;
    const int eDown = m_numberOfSpinDownElectrons;
    m_slaterUp      = zeros<mat>(eUp,   eUp);
    m_slaterDown    = zeros<mat>(eDown, eDown);

    vector<Electron*> spinUpElectrons   = m_system->getSpinUpElectrons();
    vector<Electron*> spinDownElectrons = m_system->getSpinDownElectrons();

    for (int electron = 0; electron < eUp; electron++) {
        const double x = spinUpElectrons.at(electron)->getPosition().at(0);
        const double y = spinUpElectrons.at(electron)->getPosition().at(1);
        const double z = spinUpElectrons.at(electron)->getPosition().at(2);

        for (int basis = 0; basis < eUp; basis++) {
            m_slaterUp(electron,basis) = m_orbital->evaluate(x,y,z,basis,1);
        }
    }
    for (int electron = 0; electron < eDown; electron++) {
        const double x = spinDownElectrons.at(electron)->getPosition().at(0);
        const double y = spinDownElectrons.at(electron)->getPosition().at(1);
        const double z = spinDownElectrons.at(electron)->getPosition().at(2);

        for (int basis = 0; basis < eDown; basis++) {
            m_slaterDown(electron,basis) = m_orbital->evaluate(x,y,z,basis,0);
        }
    }

    m_slaterUp   = m_slaterUp.i();
    m_slaterDown = m_slaterDown.i();
    ...
}
\end{lstlisting}

\subsubsection{Efficient evaluation of the gradient, $\nabla_i |D|$}



\subsection{The Orbital class \label{orbital}}










\end{document}